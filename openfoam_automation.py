from __future__ import annotations

import argparse
import math
import shutil
import subprocess
from dataclasses import dataclass
from pathlib import Path

from fin_wall_stl import generate_fin_wall_geometry


@dataclass(frozen=True)
class GeometryParams:
    gap: float
    T: float
    H_wall: float
    W_wall: float
    p: float
    t: float
    L: float


@dataclass(frozen=True)
class MeshingParams:
    margin: float = 0.02
    background_cell_size: float = 0.005
    target_surface_cell_size: float | None = None
    max_local_cells: int = 2_000_000
    max_global_cells: int = 10_000_000
    min_refinement_cells: int = 10
    n_cells_between_levels: int = 2
    resolve_feature_angle_deg: float = 30.0


def _max_count_with_gap(total_length: float, thickness: float, gap: float) -> int:
    if total_length <= 0:
        return 0
    if thickness <= 0:
        return 0
    if gap < 0:
        return 0
    return int(math.floor((total_length + gap) / (thickness + gap) + 1e-12))


def _blockmesh_cell_count(length: float, cell_size: float, min_cells: int = 10) -> int:
    if length <= 0:
        return min_cells
    if cell_size <= 0:
        return min_cells
    return max(min_cells, int(math.ceil(length / cell_size)))


def generate_blockmeshdict_text(geom: GeometryParams, mesh: MeshingParams) -> str:
    x_min = -geom.gap / 2 - geom.T - mesh.margin
    x_max = geom.gap / 2 + geom.T + mesh.margin
    y_min = 0.0 - mesh.margin
    y_max = geom.H_wall + mesh.margin
    z_min = 0.0 - mesh.margin
    z_max = geom.W_wall + mesh.margin

    Lx = x_max - x_min
    Ly = y_max - y_min
    Lz = z_max - z_min

    nx = _blockmesh_cell_count(Lx, mesh.background_cell_size)
    ny = _blockmesh_cell_count(Ly, mesh.background_cell_size)
    nz = _blockmesh_cell_count(Lz, mesh.background_cell_size)

    return f"""/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}}
// Generated by openfoam_automation.py

scale   1;

vertices
(
    ({x_min:.6f}  {y_min:.6f}  {z_min:.6f})  // 0
    ({x_max:.6f}  {y_min:.6f}  {z_min:.6f})  // 1
    ({x_max:.6f}  {y_max:.6f}  {z_min:.6f})  // 2
    ({x_min:.6f}  {y_max:.6f}  {z_min:.6f})  // 3
    ({x_min:.6f}  {y_min:.6f}  {z_max:.6f})  // 4
    ({x_max:.6f}  {y_min:.6f}  {z_max:.6f})  // 5
    ({x_max:.6f}  {y_max:.6f}  {z_max:.6f})  // 6
    ({x_min:.6f}  {y_max:.6f}  {z_max:.6f})  // 7
);

blocks
(
    hex (0 1 2 3 4 5 6 7) ({nx} {ny} {nz}) simpleGrading (1 1 1)
);

edges
();

boundary
(
    background
    {{
        type patch;
        faces
        (
            (3 7 6 2)  // yMax
            (1 5 4 0)  // yMin
            (0 4 7 3)  // xMin
            (2 6 5 1)  // xMax
            (0 3 2 1)  // zMin
            (4 5 6 7)  // zMax
        );
    }}
);

mergePatchPairs
();

// ************************************************************************* //
"""


def _surface_refinement_level(
    background_cell_size: float, target_cell_size: float
) -> int:
    if background_cell_size <= 0 or target_cell_size <= 0:
        return 0
    ratio = background_cell_size / target_cell_size
    if ratio <= 1.0:
        return 0
    return int(math.ceil(math.log(ratio, 2)))


def _safe_location_in_mesh(geom: GeometryParams) -> tuple[float, float, float]:
    # Find a point in the y-z gap between fins (if p > 0 and at least 2 cells each).
    num_y = _max_count_with_gap(geom.H_wall, geom.t, geom.p)
    num_z = _max_count_with_gap(geom.W_wall, geom.t, geom.p)
    used_y = num_y * geom.t + (num_y - 1) * geom.p
    used_z = num_z * geom.t + (num_z - 1) * geom.p
    y_start = (geom.H_wall - used_y) / 2
    z_start = (geom.W_wall - used_z) / 2

    if geom.p > 0 and num_y >= 2 and num_z >= 2:
        y = y_start + geom.t + 0.5 * geom.p
        z = z_start + geom.t + 0.5 * geom.p
        return (0.0, y, z)

    # Fallback: pick a point near the left wall-side in x, centered in y/z.
    eps = min(1e-4, geom.gap * 1e-3)
    x = -geom.gap / 2 + eps
    y = geom.H_wall / 2
    z = geom.W_wall / 2
    return (x, y, z)


def generate_snappyhexmeshdict_text(
    geom: GeometryParams, mesh: MeshingParams, tri_surface_dir: Path
) -> str:
    stl_files = sorted(tri_surface_dir.glob("*.stl"))
    if not stl_files:
        raise FileNotFoundError(f"No STL files found in {tri_surface_dir}")

    target_size = mesh.target_surface_cell_size
    if target_size is None:
        target_size = max(geom.t / 2.0, 1e-6)

    level = _surface_refinement_level(mesh.background_cell_size, target_size)
    level_pair = f"({level} {level})"

    location = _safe_location_in_mesh(geom)
    location_str = f"({location[0]:.6f} {location[1]:.6f} {location[2]:.6f})"

    geometry_entries = []
    refinement_entries = []
    for f in stl_files:
        name = f.stem
        geometry_entries.append(
            f"    {f.name}\n    {{\n        type triSurfaceMesh;\n        name {name};\n    }}\n"
        )
        refinement_entries.append(
            "    "
            + name
            + "\n    {\n        level "
            + level_pair
            + ";\n        patchInfo { type wall; }\n    }\n"
        )

    geometry_block = "".join(geometry_entries)
    refinement_block = "".join(refinement_entries)

    return f"""/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      snappyHexMeshDict;
}}
// Generated by openfoam_automation.py

castellatedMesh true;
snap            true;
addLayers       false;

geometry
{{
{geometry_block}}}

castellatedMeshControls
{{
    maxLocalCells {mesh.max_local_cells};
    maxGlobalCells {mesh.max_global_cells};
    minRefinementCells {mesh.min_refinement_cells};
    nCellsBetweenLevels {mesh.n_cells_between_levels};

    features
    (
    );

    refinementSurfaces
    {{
{refinement_block}    }}

    resolveFeatureAngle {mesh.resolve_feature_angle_deg:.1f};

    refinementRegions
    {{
    }}

    locationInMesh {location_str};
    allowFreeStandingZoneFaces true;
}}

snapControls
{{
    nSmoothPatch 3;
    tolerance 2.0;
    nSolveIter 30;
    nRelaxIter 5;
}}

addLayersControls
{{
}}

meshQualityControls
{{
    maxNonOrtho 65;
    maxBoundarySkewness 20;
    maxInternalSkewness 4;
    maxConcave 80;
    minVol 1e-13;
    minTetQuality 1e-9;
    minArea -1;
    minTwist 0.02;
    minDeterminant 0.001;
    minFaceWeight 0.02;
    minVolRatio 0.01;
    minTriangleTwist -1;
    nSmoothScale 4;
    errorReduction 0.75;
}}

writeFlags
(
    scalarLevels
    layerSets
    layerFields
);

mergeTolerance 1e-6;

// ************************************************************************* //
"""


def generate_controldict_text() -> str:
    return """/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      controlDict;
}
// Generated by openfoam_automation.py

application     simpleFoam;

startFrom       startTime;
startTime       0;

stopAt          endTime;
endTime         1;

deltaT          1;

writeControl    timeStep;
writeInterval   1;

purgeWrite      0;

writeFormat     ascii;
writePrecision  6;
writeCompression off;

timeFormat      general;
timePrecision   6;

runTimeModifiable true;

// ************************************************************************* //
"""


def write_openfoam_case_files(
    case_dir: Path, geom: GeometryParams, mesh: MeshingParams
) -> None:
    system_dir = case_dir / "system"
    tri_surface_dir = case_dir / "constant" / "triSurface"
    system_dir.mkdir(parents=True, exist_ok=True)
    tri_surface_dir.mkdir(parents=True, exist_ok=True)

    generate_fin_wall_geometry(
        gap=geom.gap,
        T=geom.T,
        H_wall=geom.H_wall,
        W_wall=geom.W_wall,
        p=geom.p,
        t=geom.t,
        L=geom.L,
        output_dir=str(tri_surface_dir),
    )

    (system_dir / "controlDict").write_text(
        generate_controldict_text(), encoding="utf-8"
    )
    (system_dir / "blockMeshDict").write_text(
        generate_blockmeshdict_text(geom, mesh), encoding="utf-8"
    )
    (system_dir / "snappyHexMeshDict").write_text(
        generate_snappyhexmeshdict_text(geom, mesh, tri_surface_dir), encoding="utf-8"
    )


def run_openfoam_meshing(case_dir: Path) -> None:
    if shutil.which("blockMesh") is None:
        raise FileNotFoundError(
            "blockMesh not found in PATH (did you source OpenFOAM?)"
        )
    if shutil.which("snappyHexMesh") is None:
        raise FileNotFoundError(
            "snappyHexMesh not found in PATH (did you source OpenFOAM?)"
        )

    subprocess.run(["blockMesh"], cwd=str(case_dir), check=True)
    subprocess.run(["snappyHexMesh", "-overwrite"], cwd=str(case_dir), check=True)


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate geometry + OpenFOAM blockMesh/snappyHexMesh dicts and run meshing."
    )
    parser.add_argument("--case-dir", default=".")
    parser.add_argument("--write-only", action="store_true")

    parser.add_argument("--gap", type=float, default=0.20)
    parser.add_argument("--T", type=float, default=0.01)
    parser.add_argument("--H-wall", type=float, default=0.10)
    parser.add_argument("--W-wall", type=float, default=0.10)
    parser.add_argument("--p", type=float, default=0.02)
    parser.add_argument("--t", type=float, default=0.005)
    parser.add_argument("--L", type=float, default=0.12)

    parser.add_argument("--margin", type=float, default=0.02)
    parser.add_argument("--background-cell-size", type=float, default=0.005)
    parser.add_argument("--target-surface-cell-size", type=float, default=None)

    args = parser.parse_args()

    case_dir = Path(args.case_dir).resolve()
    geom = GeometryParams(
        gap=args.gap,
        T=args.T,
        H_wall=args.H_wall,
        W_wall=args.W_wall,
        p=args.p,
        t=args.t,
        L=args.L,
    )
    mesh = MeshingParams(
        margin=args.margin,
        background_cell_size=args.background_cell_size,
        target_surface_cell_size=args.target_surface_cell_size,
    )

    write_openfoam_case_files(case_dir, geom, mesh)
    if not args.write_only:
        run_openfoam_meshing(case_dir)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
