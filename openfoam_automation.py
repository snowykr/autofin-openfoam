from __future__ import annotations

import argparse
import math
import shutil
import subprocess
from dataclasses import dataclass
from pathlib import Path

from fin_wall_stl import generate_fin_wall_geometry


@dataclass(frozen=True)
class GeometryParams:
    gap: float
    T: float
    H_wall: float
    W_wall: float
    p: float
    t: float
    L: float


@dataclass(frozen=True)
class MeshingParams:
    margin: float = 0.02
    background_cell_size: float = 0.005
    target_surface_cell_size: float | None = None
    max_local_cells: int = 2_000_000
    max_global_cells: int = 10_000_000
    min_refinement_cells: int = 10
    n_cells_between_levels: int = 2
    resolve_feature_angle_deg: float = 30.0
    # Feature snapping is enabled by default because it is required to preserve
    # sharp fin-wall edges reliably for this geometry.
    # NOTE: When using --write-only, you must run the feature tool before snappyHexMesh.
    feature_snap: bool = True
    feature_tool: str = "surfaceFeatures"  # or "surfaceFeatureExtract"
    feature_extract_included_angle_deg: float = 150.0


def _max_count_with_gap(total_length: float, thickness: float, gap: float) -> int:
    if total_length <= 0:
        return 0
    if thickness <= 0:
        return 0
    if gap < 0:
        return 0
    return int(math.floor((total_length + gap) / (thickness + gap) + 1e-12))


def _blockmesh_cell_count(length: float, cell_size: float, min_cells: int = 10) -> int:
    if length <= 0:
        return min_cells
    if cell_size <= 0:
        return min_cells
    return max(min_cells, int(math.ceil(length / cell_size)))


def generate_blockmeshdict_text(geom: GeometryParams, mesh: MeshingParams) -> str:
    x_min = -geom.gap / 2 - geom.T - mesh.margin
    x_max = geom.gap / 2 + geom.T + mesh.margin
    # Important: keep y/z tight to the wall extents so the region outside the
    # wall+gap+wall footprint cannot connect around the wall edges.
    y_min = 0.0
    y_max = geom.H_wall
    z_min = 0.0
    z_max = geom.W_wall

    Lx = x_max - x_min
    Ly = y_max - y_min
    Lz = z_max - z_min

    nx = _blockmesh_cell_count(Lx, mesh.background_cell_size)
    ny = _blockmesh_cell_count(Ly, mesh.background_cell_size)
    nz = _blockmesh_cell_count(Lz, mesh.background_cell_size)

    return f"""/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}}
// Generated by openfoam_automation.py

scale   1;

vertices
(
    ({x_min:.6f}  {y_min:.6f}  {z_min:.6f})  // 0
    ({x_max:.6f}  {y_min:.6f}  {z_min:.6f})  // 1
    ({x_max:.6f}  {y_max:.6f}  {z_min:.6f})  // 2
    ({x_min:.6f}  {y_max:.6f}  {z_min:.6f})  // 3
    ({x_min:.6f}  {y_min:.6f}  {z_max:.6f})  // 4
    ({x_max:.6f}  {y_min:.6f}  {z_max:.6f})  // 5
    ({x_max:.6f}  {y_max:.6f}  {z_max:.6f})  // 6
    ({x_min:.6f}  {y_max:.6f}  {z_max:.6f})  // 7
);

blocks
(
    hex (0 1 2 3 4 5 6 7) ({nx} {ny} {nz}) simpleGrading (1 1 1)
);

edges
();

boundary
(
    background
    {{
        type patch;
        faces
        (
            (3 7 6 2)  // yMax
            (1 5 4 0)  // yMin
            (0 4 7 3)  // xMin
            (2 6 5 1)  // xMax
            (0 3 2 1)  // zMin
            (4 5 6 7)  // zMax
        );
    }}
);

mergePatchPairs
();

// ************************************************************************* //
"""


def _surface_refinement_level(
    background_cell_size: float, target_cell_size: float
) -> int:
    if background_cell_size <= 0 or target_cell_size <= 0:
        return 0
    ratio = background_cell_size / target_cell_size
    if ratio <= 1.0:
        return 0
    return int(math.ceil(math.log(ratio, 2)))


def _safe_location_in_mesh(
    geom: GeometryParams, mesh: MeshingParams
) -> tuple[float, float, float]:
    """Pick a point strictly inside the kept *fluid* region.

    Requirements:
    - Must be inside the blockMesh bounds.
    - Must be outside all solid STL volumes (walls and fins).
    - Must not lie on/too close to surfaces/mesh boundaries (numerical stability).
    """

    def _clamp(v: float, lo: float, hi: float) -> float:
        return min(max(v, lo), hi)

    def _grid_params() -> tuple[int, int, float, float, float, float, float]:
        num_y = _max_count_with_gap(geom.H_wall, geom.t, geom.p)
        num_z = _max_count_with_gap(geom.W_wall, geom.t, geom.p)
        used_y = num_y * geom.t + (num_y - 1) * geom.p if num_y > 0 else 0.0
        used_z = num_z * geom.t + (num_z - 1) * geom.p if num_z > 0 else 0.0
        y_start = (geom.H_wall - used_y) / 2 if geom.H_wall > 0 else 0.0
        z_start = (geom.W_wall - used_z) / 2 if geom.W_wall > 0 else 0.0
        pitch = geom.t + geom.p
        return num_y, num_z, used_y, used_z, y_start, z_start, pitch

    def _cell_indices(
        y: float, z: float, y_start: float, z_start: float, pitch: float
    ) -> tuple[int, int]:
        # y/z are expected to be within the used band when this is called.
        iy = int((y - y_start) / pitch)
        iz = int((z - z_start) / pitch)
        return iy, iz

    def _in_used_band(
        y: float, z: float, y_start: float, z_start: float, used_y: float, used_z: float
    ) -> bool:
        return (y_start <= y <= y_start + used_y) and (z_start <= z <= z_start + used_z)

    def _inside_fin_footprint(
        y: float,
        z: float,
        y_start: float,
        z_start: float,
        used_y: float,
        used_z: float,
        pitch: float,
    ) -> tuple[bool, int, int]:
        if pitch <= 0:
            return False, -1, -1
        if not _in_used_band(y, z, y_start, z_start, used_y, used_z):
            return False, -1, -1
        iy, iz = _cell_indices(y, z, y_start, z_start, pitch)
        # Guard against y/z at the upper boundary due to float rounding.
        iy = min(max(iy, 0), max(0, num_y - 1))
        iz = min(max(iz, 0), max(0, num_z - 1))
        y0 = y_start + iy * pitch
        z0 = z_start + iz * pitch
        in_y = (y0 <= y) and (y < y0 + geom.t)
        in_z = (z0 <= z) and (z < z0 + geom.t)
        return (in_y and in_z), iy, iz

    def _point_inside_wall_solid(x: float, y: float, z: float) -> bool:
        if not (0.0 <= y <= geom.H_wall and 0.0 <= z <= geom.W_wall):
            return False
        if (-geom.gap / 2 - geom.T) <= x <= (-geom.gap / 2):
            return True
        if (geom.gap / 2) <= x <= (geom.gap / 2 + geom.T):
            return True
        return False

    def _point_inside_fin_solid(
        x: float,
        y: float,
        z: float,
        y_start: float,
        z_start: float,
        used_y: float,
        used_z: float,
        pitch: float,
    ) -> bool:
        in_fp, iy, iz = _inside_fin_footprint(
            y, z, y_start, z_start, used_y, used_z, pitch
        )
        if not in_fp:
            return False
        if (iy + iz) % 2 == 0:
            # Left fin.
            return (-geom.gap / 2) <= x <= (-geom.gap / 2 + geom.L)
        # Right fin.
        return (geom.gap / 2 - geom.L) <= x <= (geom.gap / 2)

    num_y, num_z, used_y, used_z, y_start, z_start, pitch = _grid_params()

    # Conservative epsilon: keep away from mesh boundaries and surfaces.
    # OpenFOAM guidance is to stay away from faces/edges; 10-20% of cell size is a good rule.
    cell_eps = max(1e-6, 0.2 * mesh.background_cell_size)
    x_lo = -geom.gap / 2 + cell_eps
    x_hi = geom.gap / 2 - cell_eps
    y_lo = 0.0 + cell_eps
    y_hi = geom.H_wall - cell_eps
    z_lo = 0.0 + cell_eps
    z_hi = geom.W_wall - cell_eps

    if not (x_lo < x_hi and y_lo < y_hi and z_lo < z_hi):
        raise ValueError(
            "No room for a safe locationInMesh point: domain too small vs background_cell_size; reduce background_cell_size or increase dimensions."
        )

    # Candidate sets for y and z.
    y_candidates: list[float] = []
    z_candidates: list[float] = []

    # 1) Prefer a y/z gap between fins.
    if geom.p > 0 and pitch > 0:
        if num_y >= 2:
            y_candidates.append(y_start + geom.t + 0.5 * geom.p)
        if num_z >= 2:
            z_candidates.append(z_start + geom.t + 0.5 * geom.p)

    # 2) Use leftover margins outside the fin band (if any).
    y_margin_bot = y_start
    y_margin_top = geom.H_wall - (y_start + used_y)
    # Only use margin candidates if they can stay at least cell_eps away from the fin band.
    if y_margin_bot > 2 * cell_eps:
        y_candidates.append(0.5 * y_margin_bot)
    if y_margin_top > 2 * cell_eps:
        y_candidates.append(geom.H_wall - 0.5 * y_margin_top)

    z_margin_bot = z_start
    z_margin_top = geom.W_wall - (z_start + used_z)
    if z_margin_bot > 2 * cell_eps:
        z_candidates.append(0.5 * z_margin_bot)
    if z_margin_top > 2 * cell_eps:
        z_candidates.append(geom.W_wall - 0.5 * z_margin_top)

    # 3) Always include centered values as a last resort.
    y_candidates.append(geom.H_wall / 2)
    z_candidates.append(geom.W_wall / 2)

    # Deduplicate while preserving order.
    def _uniq(vals: list[float]) -> list[float]:
        out: list[float] = []
        for v in vals:
            if all(abs(v - w) > 1e-12 for w in out):
                out.append(v)
        return out

    y_candidates = _uniq([_clamp(y, y_lo, y_hi) for y in y_candidates])
    z_candidates = _uniq([_clamp(z, z_lo, z_hi) for z in z_candidates])

    clearance = geom.gap - geom.L
    for y_cand in y_candidates:
        for z_cand in z_candidates:
            y_try = y_cand
            z_try = z_cand
            # If (y,z) is not in any fin footprint, x=0 is safe (even when fins cross at x=0).
            in_fp, iy, iz = _inside_fin_footprint(
                y_try, z_try, y_start, z_start, used_y, used_z, pitch
            )
            if not in_fp:
                x = 0.0
            else:
                # Move (y,z) away from fin footprint boundaries.
                if geom.t <= 2 * cell_eps:
                    continue

                y0 = y_start + iy * pitch
                z0 = z_start + iz * pitch
                y_try = _clamp(y0 + 0.5 * geom.t, y_lo, y_hi)
                z_try = _clamp(z0 + 0.5 * geom.t, z_lo, z_hi)

                if clearance <= 2 * cell_eps:
                    # In a fully tiled y-z plane and L ~ gap, there may be no fluid region.
                    continue
                if (iy + iz) % 2 == 0:
                    # Left fin exists in this cell: pick x near the right wall inner face.
                    x = x_hi
                else:
                    # Right fin exists in this cell: pick x near the left wall inner face.
                    x = x_lo

            # Validate point is outside solids.
            if _point_inside_wall_solid(x, y_try, z_try):
                continue
            if _point_inside_fin_solid(
                x, y_try, z_try, y_start, z_start, used_y, used_z, pitch
            ):
                continue

            return (x, y_try, z_try)

    raise ValueError(
        "Failed to find a safe locationInMesh point in the kept fluid region; try increasing p (create y/z gaps), or ensure gap > L (provide clearance), or adjust H_wall/W_wall so fins do not tile the entire cross-section."
    )


def generate_snappyhexmeshdict_text(
    geom: GeometryParams, mesh: MeshingParams, tri_surface_dir: Path
) -> str:
    stl_files = sorted(tri_surface_dir.glob("*.stl"))
    if not stl_files:
        raise FileNotFoundError(f"No STL files found in {tri_surface_dir}")

    target_size = mesh.target_surface_cell_size
    if target_size is None:
        target_size = max(geom.t / 2.0, 1e-6)

    level = _surface_refinement_level(mesh.background_cell_size, target_size)
    level_pair = f"({level} {level})"

    location = _safe_location_in_mesh(geom, mesh)
    location_str = f"({location[0]:.10f} {location[1]:.10f} {location[2]:.10f})"

    geometry_entries: list[str] = []
    refinement_entries: list[str] = []
    feature_entries: list[str] = []
    for f in stl_files:
        name = f.stem
        geometry_entries.append(
            f'    {f.name}\n    {{\n        type triSurfaceMesh;\n        file "{f.name}";\n        name {name};\n    }}\n'
        )
        refinement_entries.append(
            "    "
            + name
            + "\n    {\n        level "
            + level_pair
            + ";\n        patchInfo { type wall; }\n    }\n"
        )
        if mesh.feature_snap:
            ext = (
                "extendedFeatureEdgeMesh"
                if mesh.feature_tool == "surfaceFeatures"
                else "eMesh"
            )
            feature_entries.append(
                f'        {{ file "{name}.{ext}"; level {level}; }}\n'
            )

    geometry_block = "".join(geometry_entries)
    refinement_block = "".join(refinement_entries)
    features_block = "".join(feature_entries)

    snap_feature_block = ""
    if mesh.feature_snap:
        # Note: In OpenFOAM, leaving out nFeatureSnapIter disables feature snapping.
        snap_feature_block = (
            "    nFeatureSnapIter 15;\n"
            "    implicitFeatureSnap false;\n"
            "    explicitFeatureSnap true;\n"
            "    multiRegionFeatureSnap true;\n"
        )

    return f"""/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      snappyHexMeshDict;
}}
// Generated by openfoam_automation.py

castellatedMesh true;
snap            true;
addLayers       false;

geometry
{{
{geometry_block}}}

castellatedMeshControls
{{
    maxLocalCells {mesh.max_local_cells};
    maxGlobalCells {mesh.max_global_cells};
    minRefinementCells {mesh.min_refinement_cells};
    nCellsBetweenLevels {mesh.n_cells_between_levels};

    features
    (
{features_block}    );

    refinementSurfaces
    {{
{refinement_block}    }}

    resolveFeatureAngle {mesh.resolve_feature_angle_deg:.1f};

    refinementRegions
    {{
    }}

    locationInMesh {location_str};
    allowFreeStandingZoneFaces true;
}}

snapControls
{{
    nSmoothPatch 3;
    tolerance 2.0;
    nSolveIter 30;
    nRelaxIter 5;
{snap_feature_block}
}}

addLayersControls
{{
}}

meshQualityControls
{{
    maxNonOrtho 65;
    maxBoundarySkewness 20;
    maxInternalSkewness 4;
    maxConcave 80;
    minVol 1e-13;
    minTetQuality 1e-9;
    minArea -1;
    minTwist 0.02;
    minDeterminant 0.001;
    minFaceWeight 0.02;
    minVolRatio 0.01;
    minTriangleTwist -1;
    nSmoothScale 4;
    errorReduction 0.75;
}}

writeFlags
(
    scalarLevels
    layerSets
    layerFields
);

mergeTolerance 1e-6;

// ************************************************************************* //
"""


def generate_controldict_text() -> str:
    return """/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      controlDict;
}
// Generated by openfoam_automation.py

application     simpleFoam;

startFrom       startTime;
startTime       0;

stopAt          endTime;
endTime         1;

deltaT          1;

writeControl    timeStep;
writeInterval   1;

purgeWrite      0;

writeFormat     ascii;
writePrecision  6;
writeCompression off;

timeFormat      general;
timePrecision   6;

runTimeModifiable true;

// ************************************************************************* //
"""


def generate_surfacefeatureextractdict_text(
    tri_surface_dir: Path, mesh: MeshingParams
) -> str:
    stl_files = sorted(tri_surface_dir.glob("*.stl"))
    if not stl_files:
        raise FileNotFoundError(f"No STL files found in {tri_surface_dir}")

    entries: list[str] = []
    for f in stl_files:
        entry = (
            f"{f.name}\n"
            + "{\n"
            + "    extractionMethod    extractFromSurface;\n"
            + "\n"
            + "    extractFromSurfaceCoeffs\n"
            + "    {\n"
            + f"        includedAngle   {mesh.feature_extract_included_angle_deg:.1f};\n"
            + "    }\n"
            + "\n"
            + "    writeObj            yes;\n"
            + "}\n\n"
        )
        entries.append(entry)

    entries_block = "".join(entries)

    return f"""/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      surfaceFeatureExtractDict;
}}
// Generated by openfoam_automation.py

{entries_block}// ************************************************************************* //
"""


def generate_surfacefeaturesdict_text(
    tri_surface_dir: Path, mesh: MeshingParams
) -> str:
    stl_files = sorted(tri_surface_dir.glob("*.stl"))
    if not stl_files:
        raise FileNotFoundError(f"No STL files found in {tri_surface_dir}")

    surfaces_block = "\n".join([f'    "{f.name}"' for f in stl_files])

    return f"""/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     |                                                 |
|   \\  /    A nd           |                                                 |
|    \\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "system";
    object      surfaceFeaturesDict;
}}
// Generated by openfoam_automation.py

surfaces
(
{surfaces_block}
);

// Identify a feature when angle between faces < includedAngle
includedAngle   {mesh.feature_extract_included_angle_deg:.1f};

writeObj        yes;

// ************************************************************************* //
"""


def write_openfoam_case_files(
    case_dir: Path, geom: GeometryParams, mesh: MeshingParams
) -> None:
    system_dir = case_dir / "system"
    tri_surface_dir = case_dir / "constant" / "triSurface"
    ext_features_dir = case_dir / "constant" / "extendedFeatureEdgeMesh"
    system_dir.mkdir(parents=True, exist_ok=True)
    tri_surface_dir.mkdir(parents=True, exist_ok=True)
    ext_features_dir.mkdir(parents=True, exist_ok=True)

    # Remove stale feature dictionaries (generated depending on feature_tool).
    for dict_name in ["surfaceFeaturesDict", "surfaceFeatureExtractDict"]:
        try:
            (system_dir / dict_name).unlink()
        except FileNotFoundError:
            pass

    # Remove previously generated STL files so snappyHexMeshDict does not pick up stale geometry.
    for pattern in [
        "wall_left.stl",
        "wall_right.stl",
        "fin_left_y*_z*.stl",
        "fin_right_y*_z*.stl",
    ]:
        for f in tri_surface_dir.glob(pattern):
            try:
                f.unlink()
            except FileNotFoundError:
                pass

    # Remove previously generated feature files (avoid stale feature snapping).
    for pattern in ["*.eMesh", "*.obj"]:
        for f in tri_surface_dir.glob(pattern):
            try:
                f.unlink()
            except FileNotFoundError:
                pass

    # surfaceFeatures (OpenFOAM.org/Foundation) writes to constant/extendedFeatureEdgeMesh
    for pattern in ["*.extendedFeatureEdgeMesh", "*.obj"]:
        for f in ext_features_dir.glob(pattern):
            try:
                f.unlink()
            except FileNotFoundError:
                pass

    generate_fin_wall_geometry(
        gap=geom.gap,
        T=geom.T,
        H_wall=geom.H_wall,
        W_wall=geom.W_wall,
        p=geom.p,
        t=geom.t,
        L=geom.L,
        output_dir=str(tri_surface_dir),
    )

    (system_dir / "controlDict").write_text(
        generate_controldict_text(), encoding="utf-8"
    )
    (system_dir / "blockMeshDict").write_text(
        generate_blockmeshdict_text(geom, mesh), encoding="utf-8"
    )
    if mesh.feature_snap:
        if mesh.feature_tool == "surfaceFeatures":
            (system_dir / "surfaceFeaturesDict").write_text(
                generate_surfacefeaturesdict_text(tri_surface_dir, mesh),
                encoding="utf-8",
            )
        else:
            (system_dir / "surfaceFeatureExtractDict").write_text(
                generate_surfacefeatureextractdict_text(tri_surface_dir, mesh),
                encoding="utf-8",
            )
    (system_dir / "snappyHexMeshDict").write_text(
        generate_snappyhexmeshdict_text(geom, mesh, tri_surface_dir), encoding="utf-8"
    )

    # Helper script for the common --write-only + Docker workflow.
    # This enforces the required command ordering when feature snapping is enabled.
    allmesh = (
        "#!/bin/sh\n"
        "set -eu\n"
        "blockMesh > log.blockMesh 2>&1\n"
        "if [ -f system/surfaceFeaturesDict ]; then\n"
        "  surfaceFeatures > log.surfaceFeatures 2>&1\n"
        "elif [ -f system/surfaceFeatureExtractDict ]; then\n"
        "  surfaceFeatureExtract > log.surfaceFeatureExtract 2>&1\n"
        "fi\n"
        "snappyHexMesh -overwrite > log.snappyHexMesh 2>&1\n"
    )
    allmesh_path = case_dir / "Allmesh"
    allmesh_path.write_text(allmesh, encoding="utf-8")
    try:
        allmesh_path.chmod(0o755)
    except OSError:
        # Best-effort; e.g. on some filesystems chmod may be disallowed.
        pass


def run_openfoam_meshing(case_dir: Path, mesh: MeshingParams) -> None:
    if shutil.which("blockMesh") is None:
        raise FileNotFoundError(
            "blockMesh not found in PATH (did you source OpenFOAM?)"
        )
    if shutil.which("snappyHexMesh") is None:
        raise FileNotFoundError(
            "snappyHexMesh not found in PATH (did you source OpenFOAM?)"
        )
    if mesh.feature_snap:
        if mesh.feature_tool == "surfaceFeatures":
            if shutil.which("surfaceFeatures") is None:
                raise FileNotFoundError(
                    "surfaceFeatures not found in PATH (did you source OpenFOAM?)"
                )
        else:
            if shutil.which("surfaceFeatureExtract") is None:
                raise FileNotFoundError(
                    "surfaceFeatureExtract not found in PATH (did you source OpenFOAM?)"
                )

    subprocess.run(["blockMesh"], cwd=str(case_dir), check=True)
    if mesh.feature_snap:
        if mesh.feature_tool == "surfaceFeatures":
            subprocess.run(["surfaceFeatures"], cwd=str(case_dir), check=True)
        else:
            subprocess.run(["surfaceFeatureExtract"], cwd=str(case_dir), check=True)
    subprocess.run(["snappyHexMesh", "-overwrite"], cwd=str(case_dir), check=True)


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate geometry + OpenFOAM blockMesh/snappyHexMesh dicts and run meshing."
    )
    parser.add_argument("--case-dir", default=".")
    parser.add_argument("--write-only", action="store_true")

    parser.add_argument("--gap", type=float, default=0.20)
    parser.add_argument("--T", type=float, default=0.01)
    parser.add_argument("--H-wall", type=float, default=0.10)
    parser.add_argument("--W-wall", type=float, default=0.10)
    parser.add_argument("--p", type=float, default=0.02)
    parser.add_argument("--t", type=float, default=0.005)
    parser.add_argument("--L", type=float, default=0.12)

    parser.add_argument("--margin", type=float, default=0.02)
    parser.add_argument("--background-cell-size", type=float, default=0.005)
    parser.add_argument("--target-surface-cell-size", type=float, default=None)
    parser.add_argument(
        "--feature-snap",
        action=argparse.BooleanOptionalAction,
        default=True,
        help="Enable explicit feature snapping (default: enabled).",
    )
    parser.add_argument(
        "--feature-tool",
        choices=["surfaceFeatures", "surfaceFeatureExtract"],
        default="surfaceFeatures",
    )
    parser.add_argument("--feature-included-angle-deg", type=float, default=150.0)

    args = parser.parse_args()

    case_dir = Path(args.case_dir).resolve()
    geom = GeometryParams(
        gap=args.gap,
        T=args.T,
        H_wall=args.H_wall,
        W_wall=args.W_wall,
        p=args.p,
        t=args.t,
        L=args.L,
    )
    mesh = MeshingParams(
        margin=args.margin,
        background_cell_size=args.background_cell_size,
        target_surface_cell_size=args.target_surface_cell_size,
        feature_snap=args.feature_snap,
        feature_tool=args.feature_tool,
        feature_extract_included_angle_deg=args.feature_included_angle_deg,
    )

    write_openfoam_case_files(case_dir, geom, mesh)
    if not args.write_only:
        run_openfoam_meshing(case_dir, mesh)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
